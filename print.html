<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Avendish documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="getting_started/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="getting_started/compiling.html"><strong aria-hidden="true">3.</strong> Compiling</a></li><li class="chapter-item expanded "><a href="getting_started/running.html"><strong aria-hidden="true">4.</strong> Running</a></li><li class="chapter-item expanded affix "><li class="part-title">Writing processors</li><li class="chapter-item expanded "><a href="writing_processors/ports.html"><strong aria-hidden="true">5.</strong> Adding ports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/ports.refactoring.html"><strong aria-hidden="true">5.1.</strong> Simplifying ports</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.helpers.html"><strong aria-hidden="true">5.2.</strong> Helpers for ports</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.html"><strong aria-hidden="true">5.3.</strong> Port metadatas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.range.html"><strong aria-hidden="true">5.3.1.</strong> Range</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.widget.html"><strong aria-hidden="true">5.3.2.</strong> Widget</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.helpers.html"><strong aria-hidden="true">5.3.3.</strong> Helpers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/audio.html"><strong aria-hidden="true">6.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/audio.polyphonic.html"><strong aria-hidden="true">6.1.</strong> Monophonic processors</a></li><li class="chapter-item expanded "><a href="writing_processors/audio.setup.html"><strong aria-hidden="true">6.2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="writing_processors/audio.arguments.html"><strong aria-hidden="true">6.3.</strong> Playback state</a></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/messages.html"><strong aria-hidden="true">7.</strong> Messages</a></li><li class="chapter-item expanded "><a href="writing_processors/callbacks.html"><strong aria-hidden="true">8.</strong> Callbacks</a></li><li class="chapter-item expanded "><a href="writing_processors/init.html"><strong aria-hidden="true">9.</strong> Initialization</a></li><li class="chapter-item expanded "><a href="writing_processors/midi.html"><strong aria-hidden="true">10.</strong> MIDI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/midi.example.html"><strong aria-hidden="true">10.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/images.html"><strong aria-hidden="true">11.</strong> Image</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/images.example.html"><strong aria-hidden="true">11.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Advanced features</li><li class="chapter-item expanded "><a href="advanced/ui.html"><strong aria-hidden="true">12.</strong> Custom UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/ui.layout.html"><strong aria-hidden="true">12.1.</strong> Declarative layouts</a></li><li class="chapter-item expanded "><a href="advanced/ui.painting.html"><strong aria-hidden="true">12.2.</strong> Custom items</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/injection.html"><strong aria-hidden="true">13.</strong> Feature injection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/logging.html"><strong aria-hidden="true">13.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="advanced/fft.html"><strong aria-hidden="true">13.2.</strong> FFT</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/presets.html"><strong aria-hidden="true">14.</strong> Presets</a></li><li class="chapter-item expanded "><a href="advanced/sample_accurate.html"><strong aria-hidden="true">15.</strong> Sample-accurate processing</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/processing.html"><strong aria-hidden="true">16.</strong> Processing semantics</a></li><li class="chapter-item expanded "><a href="reference/bindings.html"><strong aria-hidden="true">17.</strong> Bindings</a></li><li class="chapter-item expanded "><a href="reference/controls.html"><strong aria-hidden="true">18.</strong> Controls</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Avendish documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="making-media-objects-with-avendish"><a class="header" href="#making-media-objects-with-avendish">Making media objects with <a href="https://github.com/celtera/avendish">Avendish</a></a></h1>
<p>This book is two things: a tutorial for the usage of <a href="https://github.com/celtera/avendish">Avendish</a>, intertwined with 
an explanation of the concepts and implementation.</p>
<p>Avendish aims to enable media objects / processors authors to write the processor in the most natural way possible, and then to map this to host softwares or languages with so-called zero-cost abstraction.</p>
<blockquote>
<p>By zero-cost abstraction, we mean zero run-time cost. However, we'll see that the system actually enables extremely short compile times compared to the norm in C++.</p>
</blockquote>
<p>The library is borne from:</p>
<ul>
<li>
<p>The necessity to reduce duplication among media processors in C++. </p>
</li>
<li>
<p>Allowing to express the quintessence of a given media processor.</p>
<ul>
<li>There should be no compromise at any point: the user of the library must be able to declare all the properties, inputs, outputs of a media processor, whether it processes audio, video, MIDI, asynchronous messages, etc...</li>
<li>The way this is expressed should be the simplest possible way in C++, in the sense that the code should be as natural as possible: just declaring variables should be sufficient. The lack of proper reflection in C++ still limits this in a way, but we will see that it is already possible to get quite far !</li>
<li>For a given processor, multiple potential expressions are possible. We aim to capture most possible expressions: for instance, it may be more natural for a given audio processor to implement it in a sample-wise way (each audio sample processed one-by-one), and for another to be implemented through buffer-wise processing.</li>
</ul>
</li>
<li>
<p>The observation that the implementation of a media processor has no reason of depending on any kind of binding library: those are two entirely orthogonal concerns. Yet, due to how the language works, for the longest time writing such a processor necessarily embedded it inside some kind of run-time framework: JUCE, DPF, iPlug, etc. These frameworks are all great, but also all make compromises in terms of what is possible to express. Data types will be limited to a known list, UI will have to be written with a specific UI framework, etc. In contrast, Avendish processors are much more open ; processors can be written in their &quot;canonic&quot; form. The various bindings will then try to map as much as is possible to the environments they are bound to.</p>
</li>
</ul>
<p>In addition, such frameworks are generally not suitable for embedded platforms such as micro-controllers, etc. JUCE does not work on ESP32 :-) </p>
<p>In contrast, Avendish processors can be written in a way that does not depend on <em>any</em> existing library, not even the standard C or C++ libraries, which makes them trivially portable to such platforms. The only required thing is a C++ compiler, really!</p>
<h1 id="why-c"><a class="header" href="#why-c">Why C++</a></h1>
<p>To ease porting of most effects, which are also in C++. Step by step, we will be able to lift them towards maybe higher-level descriptions, but first I believe that having something in C++ is important to allow capturing the semantics of the vast majority of media processors in existence.</p>
<p>Also because this is the language I know best =p</p>
<p>Non-C++ alternatives exist: <a href="https://faust.grame.fr/">Faust</a> and <a href="https://soul.dev/">SOUL</a> are the two most known and are great inspirations for Avendish ; they focus however mainly on audio processing. Avendish can be used to make purely message-based processors for e.g. Max/MSP and PureData, Python objects, etc. or video processing objects (currently implemented only for <a href="https://ossia.io">ossia score</a>, but could easily be ported to e.g. Jitter for Max, GEM for PureData, etc.).</p>
<h1 id="what-is-really-avendish"><a class="header" href="#what-is-really-avendish">What is really Avendish</a></h1>
<ol>
<li>An ontology for media objects.</li>
<li>An automated binding of a part of the C++ object semantics to other languages and run-time environments.</li>
<li>An example implementation of this until C++ gets proper reflection and code generation features.</li>
<li>Very, very, very, very uncompromising on its goals.</li>
<li>Lots of fun C++20 code !</li>
</ol>
<h1 id="gimme-code"><a class="header" href="#gimme-code">GIMME CODE</a></h1>
<p>Here's an example of a complete audio processor which uses an <strong>optional</strong> library of helper types:</p>
<pre><code class="language-cpp">struct MyProcessor {
  // Define generic metadata
  halp_meta(name, &quot;Gain&quot;);
  halp_meta(author, &quot;Jean-Michaël Celerier&quot;);
  halp_meta(uuid, &quot;3183d03e-9228-4d50-98e0-e7601dd16a2e&quot;);

  // Define the inputs of our processor
  struct ins {
    halp::dynamic_audio_bus&lt;&quot;Input&quot;, double&gt; audio;
    halp::knob_f32&lt;&quot;Gain&quot;, halp::range{.min = 0., .max = 1.}&gt; gain;
  } inputs;

  // Define the outputs of our processor
  struct outs {
    halp::dynamic_audio_bus&lt;&quot;Output&quot;, double&gt; audio;
    halp::hbargraph_f32&lt;&quot;Measure&quot;, halp::range{-1., 1., 0.}&gt; measure;
  } outputs;

  // Define an optional UI layout
  struct ui {
    using enum halp::colors;
    using enum halp::layouts;
    halp_meta(name, &quot;Main&quot;)
    halp_meta(layout, hbox)
    halp_meta(background, mid)

    struct {
      halp_meta(name, &quot;Widget&quot;)
      halp_meta(layout, vbox)
      halp_meta(background, dark)

      const char* label = &quot;Hello !&quot;;
      halp::item&lt;&amp;ins::gain&gt; widget;
      const char* label2 = &quot;Gain control!&quot;;
    } widgets;

    halp::spacing spc{.width = 20, .height = 20};

    halp::item&lt;&amp;outs::measure&gt; widget2;
  };

  // Our process function
  void operator()(int N) {
    auto&amp; in = inputs.audio;
    auto&amp; out = outputs.audio;
    const double gain = inputs.gain;

    double measure = 0.;
    for (int i = 0; i &lt; in.channels; i++)
    {
      for (int j = 0; j &lt; N; j++)
      {
        out[i][j] = gain * in[i][j];
        measure += std::abs(out[i][j]);
      }
    }

    if(N &gt; 0 &amp;&amp; in.channels &gt; 0)
      outputs.measure = measure / (N * in.channels);
  }
};
</code></pre>
<p>Here is how it looks like when compiled against the <a href="https://ossia.io">ossia score</a> backend:</p>
<p><img src="images/example.gif" alt="Gain example" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor:</p>
<pre><code class="language-cpp">import std;

[[name: &quot;Hello World&quot;]]
export struct MyProcessor
{
  void operator()() { 
    std::print(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<p>... at least, in an alternative universe where C++ has gotten custom attributes and reflection on those, 
and where modules and <code>std::print</code> work consistently across all compilers ; in our universe, this is still a few years away. Keep hope, dear reader, keep hope !</p>
<h1 id="getting-started-for-good"><a class="header" href="#getting-started-for-good">Getting started, for good</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor, which works on 2022 compilers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cstdio&gt;

struct MyProcessor
{
  static consteval auto name() { return &quot;Hello World&quot;; }

  void operator()() { 
    printf(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<p>Yes, it's not much. You may even already have some in your codebase without even being aware of it ! </p>
<p>Now, you may be used to the usual APIs for making audio plug-ins and start wondering about all the things you are used too and that are missing here: </p>
<ul>
<li>Inheritance or shelving function pointers in a C struct.</li>
<li>Libraries: defining an Avendish processor does not in itself require including anything. 
A central point of the system is that everything can be defined through bare C++ constructs, without requiring the user to import types from a library. A library of helpers is nonetheless provided, to simplify some repetitive cases, but is in no way mandatory ; if anything, I encourage anyone to try to make different helper APIs that fit different coding styles.</li>
<li>Functions to process audio such as</li>
</ul>
<pre><code class="language-cpp">void process(double** inputs, double** outpus, int frames);
</code></pre>
<p>We'll see how all the usual amenities can be built on top of this and simple C++ constructs such as variables, methods and structures.</p>
<h2 id="line-by-line"><a class="header" href="#line-by-line">Line by line</a></h2>
<pre><code class="language-cpp">// This line is used to instruct the compiler to not include a header file multiple times.
#pragma once

// This line is used to allow our program to use `printf`:
#include &lt;cstdio&gt;

// This line declares a struct named HelloWorld. A struct can contain functions, variables, etc.
// It could also be a class - in C++, there is no strong semantic difference between either.
struct MyProcessor
{
  // This line declares a function that will return a visible name to show to our 
  // users.
  // - static is used so that an instance of HelloWorld is not needed: 
  //   we can just refer to the function as HelloWorld::name();
  // - consteval is used to enforce that the function can be called at compile-time, 
  //   which may enable optimizations in the backends that will generate plug-ins.
  // - auto because it does not matter much here, we know that this is a string :-)
  static consteval auto name() { return &quot;Hello World&quot;; }

  // This line declares a special function that will allow our processor to be executed as follows: 
  // 
  // HelloWorld the_processor;
  // the_processor();
  //
  // ^ the second line will call the &quot;operator()&quot; function.
  void operator()() 
  { 
    // This one should hopefully be obvious :-)
    printf(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-our-processor"><a class="header" href="#compiling-our-processor">Compiling our processor</a></h1>
<h2 id="environment-set-up"><a class="header" href="#environment-set-up">Environment set-up</a></h2>
<p>Before anything, we need a C++ compiler. The recommandation is to use Clang (at least clang-13). GCC 11 also works with some limitations. Visual Studio is sadly still not competent enough.</p>
<ul>
<li>On Windows, through <a href="https://github.com/mstorsjo/llvm-mingw/releases/tag/20220323">llvm-mingw</a>. </li>
<li>On Mac, through Xcode.</li>
<li>On Linux, through your distribution packages.</li>
</ul>
<p>Avendish's code is header-only ; however, CMake automatizes correctly linking to the relevant libraries, and generates a correct entrypoint for the targeted bindings, thus we recommend installing it.</p>
<p>Ninja is recommended: it makes the build faster.</p>
<p>The APIs and SDK that you wish to create plug-ins / bindings for must also be available: </p>
<ul>
<li>PureData: needs the PureData API.
<ul>
<li>m_pd.h and pd.lib must be findable through <code>CMAKE_PREFIX_PATH</code>.</li>
<li>On Linux this is automatic if you install PureData through your distribution.</li>
</ul>
</li>
<li>Max/MSP: needs the Max SDK.
<ul>
<li>Pass <code>-DAVND_MAXSDK_PATH=/path/to/max/sdk</code> to CMake.</li>
</ul>
</li>
<li>Python: needs pybind11.
<ul>
<li>Installable through most distro's repos.</li>
</ul>
</li>
<li>ossia: needs <a href="https://github.com/ossia/libossia">libossia</a>.</li>
<li>clap: needs <a href="https://github.com/free-audio/clap">clap</a>.</li>
<li>UIs can be built with Qt or <a href="https://github.com/Immediate-Mode-UI/Nuklear">Nuklear</a>.
<ul>
<li>Qt is installable easily through <a href="https://github.com/miurahr/aqtinstall">aqtinstall</a>.</li>
</ul>
</li>
<li>VST3: needs the Steinberg VST3 SDK.
<ul>
<li>Pass <code>-DVST3_SDK_ROOT=/path/to/vst3/sdk</code> to CMake.</li>
</ul>
</li>
<li>By default, plug-ins compatible with most DAWs through an obsolete, Vintage, almost vestigial, API will be built. This does not require any specific dependency to be installed, on the other hand it only supports audio plug-ins.</li>
</ul>
<h2 id="building-the-template"><a class="header" href="#building-the-template">Building the template</a></h2>
<p>The simplest way to get started is from the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/CMakeLists.txt">template repository</a>: simply clear the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.cpp">Processor.cpp</a> file for now and put the content in <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.hpp">Processor.hpp</a>.</p>
<p>Here's a complete example (from bash):</p>
<pre><code class="language-bash">$ git clone https://github.com/celtera/avendish-audio-processor-template
$ mkdir build
$ cd build
$ cmake ../avendish-audio-processor-template
$ ninja # or make -j8
</code></pre>
<p>This should produce various binaries in the build folder: for instance, a PureData object (in <code>build/pd</code>), a Python one (in <code>build/python</code>, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-template-in-python"><a class="header" href="#running-the-template-in-python">Running the template in Python</a></h1>
<p>Once the processor is built, we can for instance run it in Python: </p>
<p>Let's try to run our processor through the Python bindings:</p>
<pre><code class="language-bash">$ cd build/python

# Check that our processor was built correctly
$ ls
pymy_processor.so

# Run it
$ python
&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Hello_World()
&gt;&gt;&gt; proc.process()
Henlo
</code></pre>
<h1 id="running-the-template-in-puredata"><a class="header" href="#running-the-template-in-puredata">Running the template in PureData</a></h1>
<p>Similarly, one can run the template in PureData: </p>
<pre><code class="language-bash">$ cd build/pd

# Check that our processor was built correctly
$ ls
my_processor.l_ia64

# Run it
$ pd -lib my_processor
</code></pre>
<p>Make the following patch:</p>
<p><img src="getting_started/../images/getting_started/pd-hello-world.png" alt="Hello PureData" /></p>
<p>When sending a bang, the terminal in which PureData was launched should also print &quot;Henlo&quot;.
We'll see in a later chapter how to print on Pd's own console instead.</p>
<h1 id="running-in-daws"><a class="header" href="#running-in-daws">Running in DAWs</a></h1>
<p>We could, but so far our object is not really an object that makes sense in a DAW: it does not process audio in any way. We'll see in further chapters how to make audio objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-ports"><a class="header" href="#adding-ports">Adding ports</a></h1>
<p>Our processor so far does not process much. It just reacts to an external trigger, to invoke a print function.</p>
<blockquote>
<p>Note that the way this trigger is invoked varies between environments: in Python, we called a <code>process()</code> function, while in PureData, we sent a bang to our object. That is one of the core philosophies of Avendish: bindings should make it so that the object fits as much as possible with the environment's semantics and idioms.</p>
</blockquote>
<p>Most actual media processing systems work with the concept of ports to declare inputs and outputs, and Avendish embraces this fully.</p>
<p>Here is the code of a simple processor, which computes the sum of two numbers.</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { float value; } a;
    struct { float value; } b;
  } inputs;

  struct
  {
    struct { float value; } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Compiling and running this yields for instance a PureData object which can be used like this:</p>
<p><img src="writing_processors/images/addition.png" alt="Addition" /></p>
<p>Note that the object respects the usual semantics of PureData: sending a message to the leftmost inlet will trigger the computation. Sending a message to the other inlets will store the value internally but won't trigger the actual computation.</p>
<p>For some objects, other semantics may make sense: creating an alternative binding to PureData which would implement another behaviour, such as triggering the computation only on &quot;bang&quot; messages, or on any input on any inlet, would be a relatively easy task.</p>
<p>Let's try in Python:</p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.input_0 = 123
&gt;&gt;&gt; p.input_1 = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.output_0
579.0
</code></pre>
<p>Here the semantics follow usual &quot;object&quot; ones. You set some state on the object and call methods on it, which may change this state. </p>
<blockquote>
<p>One could also make a binding that implements functional semantics, by passing the state of the processor as an immutable object instead. Python is already slow enough, though :p</p>
</blockquote>
<h2 id="syntax-explanation"><a class="header" href="#syntax-explanation">Syntax explanation</a></h2>
<p>Some readers may be surprised by the following syntax: </p>
<pre><code class="language-cpp">struct { float value; } a;
</code></pre>
<p>What it does is declare a variable <code>a</code> whose type is an <em>unnamed</em> structure. 
Note that this is a distinct concept from <em>anonymous</em> structures: </p>
<pre><code class="language-cpp">struct { float value; };
</code></pre>
<p>which are legal in C but not in C++ (although most relevant compilers accept them), and are mostly useful for implementing unions: </p>
<pre><code class="language-cpp">union vec3 {
  struct { float x, y, z; };
  struct { float r, g, b; };
};

union vec3 v; 
v.x = 1.0; 
v.g = 2.0;
</code></pre>
<p>Motivation for using unnamed structures in Avendish is explained afterwards.</p>
<h2 id="naming-things"><a class="header" href="#naming-things">Naming things</a></h2>
<p>In an ideal world, what we would have loved is writing the following code: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    float a;
    float b;
  } inputs;

  struct
  {
    float out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>and have our Python processor expose us variables named <code>a</code>, <code>b</code> and <code>out</code>. Sadly, without reflection on names, this is not possible yet. Thus, in the meantime we use structs to embed metadata relative to the ports: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { 
      static consteval auto name() { return &quot;a&quot;; } 
      float value; 
    } a;
    struct { 
      static consteval auto name() { return &quot;b&quot;; } 
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return &quot;out&quot;; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Now our Python example is cleaner to use: </p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.a = 123
&gt;&gt;&gt; p.b = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.out
579.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h1>
<p>One can see how writing:</p>
<pre><code class="language-cpp">struct { 
  static consteval auto name() { return &quot;foobar&quot;; } 
  float value; 
} foobar;
</code></pre>
<p>for 200 controls would get boring quick. In addition, the implementation of our processing function is not as clean as we'd want: in an ideal world, it would be just: </p>
<pre><code class="language-cpp">void operator()() { outputs.out = inputs.a + inputs.b; }
</code></pre>
<p>Thankfully, we can introduce our own custom abstractions without breaking anything: the only thing that matters is that they follow the &quot;shape&quot; of what a parameter is.</p>
<p>This shape is defined (as a first approximation) as follows:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept parameter = requires (T t) { t.value = {}; };
</code></pre>
<p>In C++ parlance, this means that a type can be recognized as a parameter if</p>
<ul>
<li>It has a member called <code>value</code>.</li>
<li>This member is assignable with some default value.</li>
</ul>
<p>For instance: </p>
<pre><code class="language-cpp">struct bad_1 {
  const int value;
}; 

struct bad_2 {
  void value();
}; 

class bad_3 {
  int value;
}; 
</code></pre>
<p>are all invalid parameters.</p>
<p>This can be ensured easily by <a href="https://gcc.godbolt.org/z/c9Ko4ssM8">asking the compiler</a>: </p>
<pre><code class="language-cpp">static_assert(!parameter&lt;bad_1&gt;);
static_assert(!parameter&lt;bad_2&gt;);
static_assert(!parameter&lt;bad_3&gt;);
</code></pre>
<blockquote>
<p><code>static_assert</code> is a C++ feature which allows to check a predicate at compile-time. If the predicate is false, the compiler will report an error.</p>
</blockquote>
<p>Avendish will simply not recognize them and they won't be accessible anywhere.</p>
<p>Here are examples of valid parameters:</p>
<pre><code class="language-cpp">struct good_1 {
  int value;
}; 

struct good_2 {
  std::string value;
}; 

template&lt;typename T&gt;
struct assignable {
  T&amp; operator=(T x) { 
    printf(&quot;I changed !&quot;);
    this-&gt;v = x;
    return this-&gt;v;
  }
  T v;
};

class good_3 {
  public:
    assignable&lt;double&gt; value;
}; 
</code></pre>
<p>This can be ensured again by <a href="https://gcc.godbolt.org/z/P7aET4q3z">asking the compiler</a>: </p>
<pre><code class="language-cpp">static_assert(parameter&lt;good_1&gt;);
static_assert(parameter&lt;good_2&gt;);
static_assert(parameter&lt;good_3&gt;);
</code></pre>
<p>Avendish provides an helper library, <code>halp</code> (Helper Abstractions for Literate Programming), which match this pattern. However, users are encouraged to develop their own abstractions that fit their preferred coding style :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ports-with-the-helper-library"><a class="header" href="#ports-with-the-helper-library">Ports with the helper library</a></h1>
<p>Here is how our processor looks with the current set of helpers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  // halp_meta(A, B) expands to static consteval auto A() { return B; }
  halp_meta(name, &quot;Addition&quot;)

  struct
  {
    // val_port is a simple type which contains 
    // - a member value of type float
    // - the name() metadata method
    // - helper operators to allow easy assignment and use of the value.
    halp::val_port&lt;&quot;a&quot;, float&gt; a;
    halp::val_port&lt;&quot;b&quot;, float&gt; b;
  } inputs;

  struct
  {
    halp::val_port&lt;&quot;out&quot;, float&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>If one really does not like templates, the following macro could be defined instead to make custom ports: </p>
<pre><code class="language-cpp">#define my_value_port(Name, Type)                  \
  struct {                                         \
    static consteval auto name() { return #Name; } \
    Type value;                                    \
  } Name;

// Used like:
my_value_port(a, float)
my_value_port(b, std::string)
... etc ...
</code></pre>
<p>Likewise if one day the <a href="https://github.com/cplusplus/papers/issues/403">metaclasses</a> proposal comes to pass, it will be possible to convert:</p>
<pre><code class="language-cpp">meta_struct
{
  float a;
  float b;
} inputs;
</code></pre>
<p>into a struct of the right shape, automatically, at compile-time, and all the current bindings will keep working.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="port-metadatas"><a class="header" href="#port-metadatas">Port metadatas</a></h1>
<p>Our ports so far are very simple: floating-point values, without any more information attached than a name to show to the user.</p>
<p>Most of the time, we'll want to attach some semantic metadata to the ports: for instance, a range of acceptable values, the kind of UI widget that should be shown to the user, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-minmax-range"><a class="header" href="#defining-a-minmax-range">Defining a min/max range</a></h1>
<p>Here is how one can define a port with such a range:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;foobar&quot;; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Here is another version which will be picked up too: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;foobar&quot;; } 
  static consteval auto range() {
    struct { 
      float min = -1.;
      float max = 1.;
      float init = 0.5;
    } r;
    return r;
  };

  float value{};
} foobar;
</code></pre>
<p>More generally, in most cases, Avendish will try to make sense of the things the author declares, whether they are types, variables or functions. This is not implemented entirely consistently yet, but it is a goal of the library in order to enable various coding styles and as much freedom of expression as possible for the media processor developer.</p>
<h2 id="keeping-metadata-static"><a class="header" href="#keeping-metadata-static">Keeping metadata static</a></h2>
<p>Note that we should still be careful in our struct definitions to not declare normal member variables for common metadata, which would take valuable memory and mess with our cache lines. This reduces performance for no good reason: imagine instantiating 10000 &quot;processor&quot; objects, you do not want each processor to carry the overhead of storing the range as a member variable, such as this: </p>
<pre><code class="language-cpp">struct {
  const char* name = &quot;foobar&quot;;

  struct {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  } range;

  float value{};
} foobar;

// In this case:
static_assert(sizeof(foobar) == 4 * sizeof(float) + sizeof(const char*));
// sizeof(foobar) == 24 on 64-bit systems

// While in the previous cases, the &quot;name&quot; and &quot;range&quot; information is stored in a static space in the binary ; its cost is paid only once:
static_assert(sizeof(foobar) == sizeof(float));
// sizeof(foobar) == 4
</code></pre>
<h2 id="testing-on-a-processor"><a class="header" href="#testing-on-a-processor">Testing on a processor</a></h2>
<p>If we modify our example processor this way: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { 
      static consteval auto name() { return &quot;a&quot;; } 
      struct range {
        float min = -10.;
        float max = 10.;
        float init = 0.;
      };
      float value; 
    } a;
    struct { 
      static consteval auto name() { return &quot;b&quot;; } 
      struct range {
        float min = -1.;
        float max = 1.;
        float init = 0.;
      };
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return &quot;out&quot;; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>then some backends will start to be able to do interesting things, like showing relevant UI widgets, or clamping the inputs / outputs.</p>
<p>This is not possible in all back-ends, sadly. Consider for instance PureData: the way one adds a port is by passing a pointer to a floating-point value to Pd, which will write directly the inbound value at the memory address: there is no point at which we could plug-in to perform clamping of the value. </p>
<p>Two alternatives would be possible in this case: </p>
<ul>
<li>Change the back-end to instead expect all messages on the first inlet, as those can be captured. This would certainly yield lower performance as one now would have to pass a symbol indicating the parameter so that the object knows to which port the input should map.</li>
<li>Implement an abstraction layer which would duplicate the parameters with their clamped version, and perform the clamping on all parameters whenever the process function gets called. This would however be hurtful in terms of performance and memory use.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-ui-widgets"><a class="header" href="#defining-ui-widgets">Defining UI widgets</a></h1>
<p>Avendish can recognize a few names that will indicate that a widget of a certain type must be created.</p>
<p>For instance: </p>
<pre><code class="language-cpp">struct {
  enum { knob };
  static consteval auto name() { return &quot;foobar&quot;; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Simply adding the enum definition in the struct will allow the bindings to detect it at compile-time, and instantiate an appropriate UI control.</p>
<p>The following widget names are currently recognized: </p>
<pre><code>bang, impulse
button, pushbutton
toggle, checkbox,
hslider, vslider, slider
spinbox,
knob,
lineedit,
choices, enumeration
combobox, list
xy,
color,
hbargraph, vbargraph, bargraph
</code></pre>
<p>This kind of widget definition is here to enable host DAWs to automatically generate appropriate UIs automatically.</p>
<p>A further chapter will present how to create entirely custom painted UIs and widgets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-helpers"><a class="header" href="#widget-helpers">Widget helpers</a></h1>
<p>To simplify the common use case of defining a port such as &quot;slider with a range&quot;, a set of common helper types is provided.</p>
<p>Here is our example, now as refined as it can be ; almost no character is superfluous or needlessly repeated except the names of controls:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  halp_meta(name, &quot;Addition&quot;)

  struct
  {
    halp::hslider_f32&lt;&quot;a&quot;, halp::range{.min = -10, .max = 10, .init = 0}&gt; a;
    halp::knob_f32&lt;&quot;b&quot; , halp::range{.min = -1, .max = 1, .init = 0}&gt; b;
  } inputs;

  struct
  {
    halp::hbargraph_f32&lt;&quot;out&quot;, halp::range{.min = -11, .max = 11, .init = 0}&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>This is how an environment such as <em>ossia score</em> renders it: </p>
<p><img src="writing_processors/images/addition-score.gif" alt="Addition" /></p>
<p>Note that even with our helper types, the following holds:</p>
<pre><code class="language-cpp">static_assert(sizeof(MyProcessor) == 3 * sizeof(float));
</code></pre>
<p>That is, an instance of our object weighs in memory exactly the size of its inputs and outputs, nothing else. In addition, the binding libraries try extremely hard to not allocate any memory dynamically, which leads to very concise memory representations of our media objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-audio-processors"><a class="header" href="#writing-audio-processors">Writing audio processors</a></h1>
<p>The processors we wrote until now only processed &quot;control&quot; values.</p>
<p>As a convention, those are values that change infrequently, relative to the audio rate: every few milliseconds, as opposed to every few dozen microseconds for individual audio samples.</p>
<h2 id="argument-based-processors"><a class="header" href="#argument-based-processors">Argument-based processors</a></h2>
<p>Let's see how one can write a simple audio filter in Avendish: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }

  float operator()(float input) 
  {
    return std::tanh(input); 
  }
};
</code></pre>
<p>That's it. That's the processor :-)</p>
<p>Maybe you are used to writing processors that operate with buffers of samples. Fear not, here is another valid Avendish audio processor, which should reassure most readers:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  static consteval auto input_channels() { return 2; }
  static consteval auto output_channels() { return 2; }

  void operator()(double** inputs, double** outputs, int frames)
  {
    for (int c = 0; c &lt; input_channels(); ++c)
    {
      for (int k = 0; k &lt; frames; k++)
      {
        outputs[c][k] = std::tanh(inputs[c][k]);
      }
    }
  }
};
</code></pre>
<p>The middle-ground of a processor that processes a single channel is also possible (and so is the possibility to use floats or doubles for the definition of the processor):</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }

  void operator()(float* inputs, float* outputs, int frames)
  {
    for (int k = 0; k &lt; frames; k++)
    {
      outputs[k] = std::tanh(inputs[k]);
    }
  }
};
</code></pre>
<p>Those are all ways that enable quickly writing very simple effects (although a lot of ground is already covered).
For more advanced systems, with side-chains and such, it is preferable to use proper ports instead.</p>
<h2 id="port-based-processors"><a class="header" href="#port-based-processors">Port-based processors</a></h2>
<p>Here are three examples of valid audio ports:</p>
<ul>
<li>Sample-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;In&quot;; }
  float sample{};
};
</code></pre>
<ul>
<li>Channel-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Out&quot;; }
  float* channel{};
};
</code></pre>
<ul>
<li>Bus-wise, with a fixed channel count. Here, bindings will ensure that there are always as many channels allocated.</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Ins&quot;; }
  static constexpr int channels() { return 2; }
  float** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<ul>
<li>Bus-wise, with a modifiable channel count. Here, bindings will put exactly as many channels as the end-user of the software requested ; this count will be contained in <code>channels</code>. </li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Outs&quot;; }
  int channels = 0;
  double** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<blockquote>
<p>An astute reader may wonder why one could not fix a channel count by doing <code>const int channels = 2;</code> instead of <code>int channels() { return 2; };</code>. Sadly, this would make our types non-assignable, which makes things harder. It would also use bytes for each instance of the processor. A viable middle-ground could be <code>static constexpr int channels = 2;</code> but C++ does not allow static variables in unnamed types, thus this does not leave a lot of choice.</p>
</blockquote>
<h2 id="process-function-for-ports"><a class="header" href="#process-function-for-ports">Process function for ports</a></h2>
<p>For ports-based processor, the process function takes the number of frames as argument. Here is a complete, bare example of a gain processor. </p>
<pre><code class="language-cpp">struct Gain {
  static constexpr auto name() { return &quot;Gain&quot;; }
  struct {
    struct {
      static constexpr auto name() { return &quot;Input&quot;; }
      const double** samples;
      int channels;
    } audio;

    struct {
      static constexpr auto name() { return &quot;Gain&quot;; }
      struct range {
        const float min = 0.;
        const float max = 1.;
        const float init = 0.5;
      };

      float value;
    } gain;
  } inputs;

  struct {
    struct {
      static constexpr auto name() { return &quot;Output&quot;; }
      double** samples;
      int channels;
    } audio;
  } outputs;
  
  void operator()(int N) {
    auto&amp; in = inputs.audio.samples;
    auto&amp; out = outputs.audio.samples;

    for (int i = 0; i &lt; p1.channels; i++) 
      for (int j = 0; j &lt; N; j++) 
        out[i][j] = inputs.gain.value * in[i][j];
  }
};
</code></pre>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<p><code>halp</code> provides helper types for these common cases: </p>
<pre><code class="language-cpp">halp::audio_sample&lt;&quot;A&quot;, double&gt; audio;
halp::audio_channel&lt;&quot;B&quot;, double&gt; audio;
halp::fixed_audio_bus&lt;&quot;C&quot;, double, 2&gt; audio;
halp::dynamic_audio_bus&lt;&quot;D&quot;, double&gt; audio;
</code></pre>
<blockquote>
<p>Important: it is not possible to mix different types of audio ports in a single processor: audio sample and audio bus operate necessarily on different time-scales that are impossible to combine in a single function. Technically, it would be possible to combine audio channels and audio buses, but for the sake of simplicity this is currently forbidden.</p>
</blockquote>
<blockquote>
<p>Likewise, it is forbidden to mix float and double inputs for audio ports (as it simply does not make sense: no host in existence is able to provide audio in two different formats at the same time).</p>
</blockquote>
<h2 id="gain-processor-helpers-version"><a class="header" href="#gain-processor-helpers-version">Gain processor, helpers version</a></h2>
<p>The exact same example as above, just shorter to write :)</p>
<pre><code class="language-cpp">struct Gain {
  static constexpr auto name() { return &quot;Gain&quot;; }
  struct {
    halp::dynamic_audio_bus&lt;&quot;Input&quot;, double&gt; audio;
    halp::hslider_f32&lt;&quot;Gain&quot;, avnd::range{0., 1., 0.5}&gt; gain;
  } inputs;

  struct {
    halp::dynamic_audio_bus&lt;&quot;Output&quot;, double&gt; audio;
  } outputs;
  
  void operator()(int N) {
    auto&amp; in = inputs.audio;
    auto&amp; out = outputs.audio;
    const float gain = inputs.gain;

    for (int i = 0; i &lt; in.channels; i++) 
      for (int j = 0; j &lt; N; j++) 
        out[i][j] = gain * in[i][j];
  }
};
</code></pre>
<h2 id="further-work"><a class="header" href="#further-work">Further work</a></h2>
<p>We currently have the following matrix of possible forms of audio ports: </p>
<table><thead><tr><th></th><th>1 channel</th><th>N channels</th></tr></thead><tbody>
<tr><td>1 frame</td><td><code>float sample;</code></td><td><code>???</code></td></tr>
<tr><td>N frames</td><td><code>float* channel;</code></td><td><code>float** samples;</code></td></tr>
</tbody></table>
<p>For the N channels / 1 frame case, one could imagine for instance: </p>
<pre><code class="language-cpp">struct {
  float bus[2]; // Fixed channels case
}
</code></pre>
<p>or </p>
<pre><code class="language-cpp">struct {
  float* bus; // Dynamic channels case
}
</code></pre>
<p>to indicate a per-sample, multi-channel bus, but this has not been implemented yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monophonic-processors"><a class="header" href="#monophonic-processors">Monophonic processors</a></h1>
<p>There are three special cases: </p>
<ol>
<li>Processors with one sample input and one sample output.</li>
<li>Processors with one channel input and one channel output.</li>
<li>Processors with one dynamic bus input, one dynamic bus output, and no fixed channels being specified.</li>
</ol>
<p>In these three cases, the processor is recognized as polyphony-friendly. That means that in cases 1 and 2, the processor will be instantiated potentially multiple times automatically, if used in e.g. a stereo DAW.</p>
<p>In case 3, the channels of inputs and outputs will be set to the same count, which comes from the host.</p>
<h2 id="polyphonic-processors-should-use-types-for-their-io"><a class="header" href="#polyphonic-processors-should-use-types-for-their-io">Polyphonic processors should use types for their I/O</a></h2>
<p>Let's consider the following processor:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct {
    struct { float value; } gain;
  } inputs;

  double operator()(double input) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(inputs.gain.value * input + accumulator); 
  }
  
private:
  double accumulator{};
};
</code></pre>
<p>We have three different values involved: </p>
<ul>
<li><code>input</code> is the audio sample that is to be processed.</li>
<li><code>inputs.gain.value</code> is an external control which increases or decreases the distortion.</li>
<li><code>accumulator</code> is an internal variable used by the processing algorithm.</li>
</ul>
<p>Now consider this in the context of polyphony: the only thing that we can do is instantiate <code>MyProcessor</code> three times.</p>
<ul>
<li>We cannot call <code>operator()</code> of a single instance on multiple channels, as the internal state must stay independent of the channels.</li>
<li>But now the inputs are duplicated for all instances. If we want to implement a filter bank with thousands of duplicated processors in parallel, this would be a huge waste of memory if they all depend on the same <code>gain</code> value.</li>
</ul>
<p>Thus, it is recommended in this case to use the following form: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct inputs {
      struct { float value; } gain;
  };
  struct outputs { };

  double operator()(double input, const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(ins.gain.value * input + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Here, Avendish will instantiate a single <code>inputs</code> array, which will be shared across all polyphony voices, which will likely use less memory and be more performant in case of large amount of parameters &amp; voices.</p>
<p>Here is what I would term the &quot;canonic&quot; of this version, with additionally our helpers to reduce typing, and the audio samples passed through ports instead of through arguments:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct inputs {
    halp::audio_sample&lt;&quot;In&quot;, double&gt; audio;
    halp::hslider_f32&lt;&quot;Gain&quot;, halp::range{.min = 0, .max = 100, .init = 1}&gt; gain;
  };
  struct outputs { 
    halp::audio_sample&lt;&quot;A&quot;, double&gt; audio;
  };

  void operator()(const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator + 0.01f, 10.f);
    outs.audio = std::tanh(ins.gain * ins.audio + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Passing inputs and outputs as types is also possible for all the other forms described previously - everything is possible, write your plug-ins as it suits you best :) and who knows, maybe with metaclasse one would also be able to generate the more efficient form directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-setup"><a class="header" href="#audio-setup">Audio setup</a></h1>
<p>It is fairly common for audio systems to need to have some buffers allocated or perform pre-computations depending on the sample rate and buffer size of the system.</p>
<p>This can be done by adding the following method in the processor:</p>
<pre><code class="language-cpp">void prepare(/* some_type */ info) {
    ...
}
</code></pre>
<p><code>some_type</code> can be a custom type with the following allowed fields: </p>
<ul>
<li><code>rate</code>: will be filled with the sample rate.</li>
<li><code>frames</code>: will be filled with the maximum frame (buffer) size.</li>
<li><code>input_channels</code> / <code>output_channels</code>: for processors with unspecified numbers of channels, it will be notified here.</li>
<li>Alternatively, just specifying <code>channels</code> works too if inputs and outputs are expected to be the same.</li>
</ul>
<p>Those variables must be assignable, and are all optional (remember the foreword: Avendish is <strong>UNCOMPROMISING</strong>).</p>
<p>Here are some valid examples:</p>
<ul>
<li>No member at all: this can be used to just notify the processor than processing is about to start.</li>
</ul>
<pre><code class="language-cpp">struct setup_a { };
void prepare(setup_a info) {
    ...
}
</code></pre>
<ul>
<li>Most common use case</li>
</ul>
<pre><code class="language-cpp">struct setup_b {
  float rate{};
  int frames{};
};
void prepare(setup_b info) {
    ...
}
</code></pre>
<ul>
<li>For variable channels in simple audio filters:</li>
</ul>
<pre><code class="language-cpp">struct setup_c {
  float rate{};
  int frames{};
  int channels{};
};
void prepare(setup_c info) {
    ...
}
</code></pre>
<h1 id="how-does-this-work-"><a class="header" href="#how-does-this-work-">How does this work ?</a></h1>
<p>If you are interested in the implementation, it is actually fairly simple.</p>
<ul>
<li>First we extract the function arguments of <code>prepare</code> if the function exists (see <code>avnd/common/function_reflection.hpp</code> for the method), to get the type <code>T</code> of the first argument.</li>
<li>Then we do the following if it exists:</li>
</ul>
<pre><code class="language-cpp">using type = /* type of T in prepare(T t) */;
if constexpr(requires (T t) { t.frames = 123; })
  t.frames = ... the buffer size reported by the DAW ...;
if constexpr(requires (T t) { t.rate = 44100; })
  t.rate = ... the sample-rate reported by the DAW ...;
</code></pre>
<p>This way, only the cost of the variables that are actually used by the algorithm is ever incurred, which is of course not super important but a good reference implementation for this way of doing for other parts of the system where it matters more. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-arguments"><a class="header" href="#audio-arguments">Audio arguments</a></h1>
<p>In addition of the global set-up step, one may require per-process-step arguments.
Most common needs are for instance the current tempo, etc.</p>
<p>The infrastructure put in place for this is very similar to the one previously mentioned for 
the setup step.</p>
<p>The way it is done is simply by passing it as the last argument of the processing <code>operator()</code> function.</p>
<p>If there is such a type, it will contain at least the frames.</p>
<blockquote>
<p>Note: due to a lazy developer, currently this type has to be called <code>tick</code>.</p>
</blockquote>
<p>Example:</p>
<pre><code class="language-cpp">struct MyProcessor {
  ...

  struct tick {
    int frames;
    double tempo;
  };

  void operator()(tick tick) { ... }
  float operator()(float in, tick tick) { ... }
  void operator()(float* in, float* out, tick tick) { ... }
  void operator()(float** in, float** out, tick tick) { ... }

// And also the variants that take input and output types as arguments

  void operator()(const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  float operator()(float in, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  void operator()(float* in, float* out, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  void operator()(float** in, float** out, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
};
</code></pre>
<p>The currently supported members are: </p>
<ul>
<li><code>frames</code>: the buffer size</li>
</ul>
<p>The plan is to introduce: </p>
<ul>
<li><code>tempo</code> and all things relative to musicality, e.g. current bar, etc. 
<ul>
<li>But first we have to define it in a proper way, which is compatible with VST, CLAP, etc.</li>
</ul>
</li>
<li><code>time_since_start</code></li>
<li>and other similar timing-related things which will all be able to be opt-in.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>So far, we already have something which allows to express a great deal of audio plug-ins, as well as many objects that do not operate in a manner synchronized to a constant sound input, but also in a more asynchronous way, and with things more complicated than single <code>float</code>, <code>int</code> or <code>string</code> values.</p>
<p>A snippet of code is worth ten thousand words: here is how one defines a message input.</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct messages {
    struct {
      static consteval auto name() { return &quot;dump&quot;; }
      void operator()(MyProcessor&amp; p, double arg1, std::string_view arg2) {
        std::cout &lt;&lt; arg1 &lt;&lt; &quot;;&quot; &lt;&lt; arg2 &lt;&lt; &quot;\n&quot;;
      }
    } my_message;
  };
};
</code></pre>
<p>Note that the <code>messages</code> are stored in a structure named <code>messages</code>. It could also be the name of the value, but this would likely use at least a few bytes per instance which would be wasted as messages are not supposed to have states themselves.</p>
<p>Messages are of course only meaningful in environments which support them. 
One argument messages are equivalent to parameters.
If there is more than one argument, not all host systems may be able to handle them ; for instance, it does not make much sense for VST3 plug-ins. On the other hand, programming language bindings or systems such as Max and PureData have no problem with them.</p>
<h2 id="passing-existing-functions"><a class="header" href="#passing-existing-functions">Passing existing functions</a></h2>
<p>The following syntaxes are also possible:</p>
<pre><code class="language-cpp">void free_function() { printf(&quot;Free function\n&quot;); }

struct MyProcessor {
  void my_member(int x);

  struct messages {
    // Using a pointer-to-member function
    struct {
      static consteval auto name() { return &quot;member&quot;; }
      static consteval auto func() { return &amp;MyProcessor::my_member; }
    } member;

    // Using a lambda-function
    struct
    {
      static consteval auto name() { return &quot;lambda_function&quot;; }
      static consteval auto func() {
        return [] { printf(&quot;lambda\n&quot;); };
      }
    } lambda;

    // Using a free function
    struct
    {
      static consteval auto name() { return &quot;function&quot;; }
      static consteval auto func() { return free_function; }
    } freefunc;
  };
};
</code></pre>
<p>In every case, if one wants access to the processor object, it has to be the first argument of the function (except the non-static-member-function case where it is not necessary as the function already has access to the <code>this</code> pointer by definition).</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type-checking</a></h2>
<p>Messages are type-checked: in the example above, for instance, PureData will return an error for the message <code>[dump foo bar&gt;</code>. For the message <code>[dump 0.1 bar&gt;</code> things will however work out just fine :-)</p>
<h2 id="arbitrary-inputs"><a class="header" href="#arbitrary-inputs">Arbitrary inputs</a></h2>
<p>It may be necessary to have messages that accept an arbitrary number of inputs.
Here is how: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;args&quot;; }
  void operator()(MyProcessor&amp; p, std::ranges::input_range auto range) {
    for(const std::variant&amp; argument : range) {
      // Print the argument whatever the content
      // (a library such as fmt can do that directly)
      std::visit([](auto&amp; e) { std::cout &lt;&lt; e &lt;&lt; &quot;\n&quot;; }, argument);

      // Try to do something useful with it - here the types depend on what the binding give us. So far only Max and Pd support that so the only possible types are floats, doubles and std::string_view
      if(std::get_if&lt;double&gt;(argument)) { ... }
      else if(std::get_if&lt;std::string_view&gt;(argument)) { ... }
      // ... etc
    }
  }
} my_variadic_message;
</code></pre>
<h1 id="overloading"><a class="header" href="#overloading">Overloading</a></h1>
<p>Overloading is not supported yet, but there are plans for it.</p>
<h1 id="how-does-the-above-code-work-"><a class="header" href="#how-does-the-above-code-work-">How does the above code work ?</a></h1>
<p>I think that this case is pretty nice and a good example of how C++ can greatly improve type safety over C APIs: a common problem for instance with Max or Pd is accessing the incorrect member of an union when iterating the arguments to a message.</p>
<p>Avendish has the following method, which transforms a Max or Pd argument list, into an iterable coroutine-based range of <code>std::variant</code>.</p>
<pre><code class="language-cpp">using atom_iterator = avnd::generator&lt;std::variant&lt;double, std::string_view&gt;&gt;;
inline atom_iterator make_atom_iterator(int argc, t_atom* argv)
{
  for (int i = 0; i &lt; argc; ++i) {
    switch (argv[i].a_type) {
      case A_FLOAT: {
        co_yield argv[i].a_w.w_float;
        break;
      }
      case A_SYM: {
        co_yield std::string_view{argv[i].a_w.w_sym-&gt;s_name};
        break;
      }
      default:
        break;
    }
  }
}
</code></pre>
<p>Here, <code>atom_iterator</code> is what gets passed to <code>my_variadic_message</code>. It allows to deport the iteration of the loop over the arguments into the calling code, but handles the matching from type to union member in a generic way and transforms them into safer <code>std::variant</code> instances on-the-fly, which removes an entire class of possible errors while not costing much : in my experiments for instance, the compiler is able to elide entirely any form of dynamic memory allocation which would normally be required there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>Just like messages allow to define functions that will be called from an outside request, it is also possible to define callbacks: functions that our processor will call, and which will be sent to the outside world.</p>
<p>Just like for messages, this does not really make sense for instance for audio processors ; however it is pretty much necessary to make useful Max or Pd objects.</p>
<p>Callbacks are defined as part of the <code>outputs</code> struct.</p>
<h2 id="defining-a-callback-with-stdfunction"><a class="header" href="#defining-a-callback-with-stdfunction">Defining a callback with std::function</a></h2>
<p>This is a first possibility, which is pretty simple:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;bong&quot;; }
  std::function&lt;void(float)&gt; call;
}; 
</code></pre>
<p>The bindings will make sure that a function is present in <code>call</code>, so that our code can call it: </p>
<pre><code class="language-cpp">struct MyProcessor {
  static consteval auto name() { return &quot;Distortion&quot;; }

  struct {
    struct {
      static consteval auto name() { return &quot;overload&quot;; }
      std::function&lt;void(float)&gt; call;
    } overload; 
  } outputs;

  float operator()(float input) 
  {
    if(input &gt; 1.0)
      outputs.overload.call(input);

    return std::tanh(input); 
  }
};
</code></pre>
<p>However, we also want to be able to live without std:: types ; in particular, std::function is a quite complex beast which does type-erasure, potential dynamic memory allocations, and may not be available on all platforms.</p>
<p>Thus, it is also possible to define callbacks with a simple pair of function-pointer &amp; context: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;overload&quot;; }
  struct {       
    void (*function)(void*, float);
    void* context;
  } call;
} overload;
</code></pre>
<p>The bindings will fill the function and function pointer, so that one can call them: </p>
<pre><code class="language-cpp">float operator()(float input) 
{
  if(input &gt; 1.0)
  {
    auto&amp; call = outputs.overload.call;
    call.function(call.context, input);
  }
  return std::tanh(input); 
}
</code></pre>
<p>Of course, this is fairly verbose: thankfully, helpers are provided to make this as simple as <code>std::function</code> but without the overhead (until <code>std::function_view</code> gets implemented):</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;overload&quot;; }
  halp::basic_callback&lt;void(float)&gt; call;
} overload;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<p>Some media systems provide a way for objects to be passed initialization arguments.</p>
<p>Avendish supports this with a special &quot;initialize&quot; method. Ultimately, I'd like to be able to simply use C++ constructors for this, but haven't managed to yet.</p>
<p>Here's an example: </p>
<pre><code class="language-cpp">struct MyProcessor {
void initialize(float a, std::string_view b)
{
  std::cout &lt;&lt; a &lt;&lt; &quot; ; &quot; &lt;&lt; b &lt;&lt; std::endl;
}
...
};
</code></pre>
<p>Max and Pd will report an error if the object is not initialized correctly, e.g. like this: </p>
<pre><code>[my_processor 1.0 foo]  // OK
[my_processor foo 1.0]  // Not OK
[my_processor] // Not OK
[my_processor 0 0 0 1 2 3] // Not OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-io"><a class="header" href="#midi-io">MIDI I/O</a></h1>
<p>Some media systems may have a concept of MIDI input / output. Note that currently this is only implemented for DAW-ish bindings: ossia, VST3, CLAP... Max and Pd do not support it yet (but if there is a standard for passing MIDI messages between objects there I'd love to hear about it !).</p>
<p>There are a few ways to specify MIDI ports.</p>
<p>Here is how one specifies unsafe MIDI ports:</p>
<pre><code class="language-cpp">struct
{
  static consteval auto name() { return &quot;MIDI&quot;; }
  struct
  {
    uint8_t bytes[3]{};
    int timestamp{}; // relative to the beginning of the tick
  }* midi_messages{};
  std::size_t size{};
} midi_port;
</code></pre>
<p>Or, more clearly:</p>
<pre><code class="language-cpp">// the name does not matter
struct midi_message {
  uint8_t bytes[3]{};
  int timestamp{}; // relative to the beginning of the tick
};

struct
{
  static consteval auto name() { return &quot;MIDI&quot;; }
  midi_message* midi_messages{};
  std::size_t size{};
} midi_port;
</code></pre>
<p>Here, Avendish bindings will allocate a large enough buffer to store MIDI messages ; this is mainly to enable writing dynamic-allocation-free backends where such a buffer may be allocated statically. </p>
<p>It is also possible to do this if you don't expect to run your code on Arduinos:</p>
<pre><code class="language-cpp">struct
{
  // Using a non-fixed size type here will enable MIDI messages &gt; 3 bytes, if for instance your 
  // processor expects to handle SYSEX messages.
  struct msg {
    std::vector&lt;uint8_t&gt; bytes;
    int64_t timestamp{};
  };

  std::vector&lt;msg&gt; midi_messages;
} midi_port;
</code></pre>
<h2 id="helpers-1"><a class="header" href="#helpers-1">Helpers</a></h2>
<p>The library provides helper types which are a good compromise between these two solutions, as they are based on <code>boost::container::small_vector</code>: for small numbers of MIDI messages, there will be no memory allocation, but pathological cases (an host sending a thousand MIDI messages in a single tick) can still be handled without loosing messages. </p>
<p>The type is very simple:</p>
<pre><code class="language-cpp">halp::midi_bus&lt;&quot;In&quot;&gt; midi;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-synth-example"><a class="header" href="#midi-synth-example">MIDI synth example</a></h1>
<p>This example is a very simple synthesizer. Note that for the sake of simplicity for the implementer, we use two additional libraries: </p>
<ul>
<li><a href="https://github.com/jcelerier/libremidi"><code>libremidi</code></a> provides an useful <code>enum</code> of common MIDI messages types.</li>
<li><a href="https://github.com/ossia/libossia"><code>libossia</code></a> provides frequency &lt;-&gt; MIDI note and gain &lt;-&gt; MIDI velocity conversion operations.</li>
</ul>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/midi.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;libremidi/message.hpp&gt;
#include &lt;ossia/network/dataspace/gain.hpp&gt;
#include &lt;ossia/network/dataspace/time.hpp&gt;
#include &lt;ossia/network/dataspace/value_with_unit.hpp&gt;

namespace examples
{
/**
 * This example exhibits a simple, monophonic synthesizer.
 * It relies on some libossia niceties.
 */
struct Synth
{
  halp_meta(name, &quot;My example synth&quot;);
  halp_meta(c_name, &quot;synth_123&quot;);
  halp_meta(category, &quot;Demo&quot;);
  halp_meta(author, &quot;Jean-Michaël Celerier&quot;);
  halp_meta(description, &quot;A demo synth&quot;);
  halp_meta(uuid, &quot;93eb0f78-3d97-4273-8a11-3df5714d66dc&quot;);

  struct
  {
    /** MIDI input: simply a list of timestamped messages.
     * Timestamp are in samples, 0 is the first sample.
     */
    halp::midi_bus&lt;&quot;In&quot;&gt; midi;
  } inputs;

  struct
  {
    halp::fixed_audio_bus&lt;&quot;Out&quot;, double, 2&gt; audio;
  } outputs;

  struct conf
  {
    int sample_rate{44100};
  } configuration;

  void prepare(conf c) { configuration = c; }

  int in_flight = 0;
  ossia::frequency last_note{};
  ossia::linear last_volume{};
  double phase = 0.;

  /** Simple monophonic synthesizer **/
  void operator()(int frames)
  {
    // 1. Process the MIDI messages. We'll just play the latest note-on
    // in a not very sample-accurate way..

    for (auto&amp; m : inputs.midi.midi_messages)
    {
      // Let's ignore channels
      switch ((libremidi::message_type) (m.bytes[0] &amp; 0xF0))
      {
        case libremidi::message_type::NOTE_ON:
          in_flight++;

          // Let's leverage the ossia unit conversion framework (adapted from Jamoma):
          // bytes is interpreted as a midi pitch and then converted to frequency.
          last_note = ossia::midi_pitch{m.bytes[1]};

          // Store the velocity in linear gain
          last_volume = ossia::midigain{m.bytes[2]};
          break;

        case libremidi::message_type::NOTE_OFF:
          in_flight--;
          break;
        default:
          break;
      }
    }

    // 2. Quit if we don't have any more note to play
    if (in_flight &lt;= 0)
      return;

    // 3. Output some bleeps
    double increment
        = ossia::two_pi * last_note.dataspace_value / double(configuration.sample_rate);
    auto&amp; out = outputs.audio.samples;

    for (int64_t j = 0; j &lt; frames; j++)
    {
      out[0][j] = last_volume.dataspace_value * std::sin(phase);
      out[1][j] = out[0][j];

      phase += increment;
    }
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-ports"><a class="header" href="#image-ports">Image ports</a></h1>
<p>Some media systems have the ability to process images. Avendish is not restricted here :-)</p>
<p>Note that this part of the system is still pretty much in flux, in particular with regards of how allocations are supposed to be handled.
Any feedback on this is welcome.</p>
<p>First, here is how we define a viable texture type:</p>
<pre><code class="language-cpp">struct my_texture
{
  enum format { RGBA }; // The only recognized one so far
  unsigned char* bytes;
  int width;
  int height;
  bool changed;
};
</code></pre>
<p>Then, a texture port:</p>
<pre><code class="language-cpp">struct {
  rgba_texture texture;
} input;
</code></pre>
<p>Note that currently, it is <em>the responsibility of the plug-in author</em> to allocate the texture and set the <code>changed</code> bool for output ports. Input textures come from outside.</p>
<p>Due to the large cost of uploading a texture, <code>changed</code> is used to indicate both to the plug-in author that input textures have been touched,and for the plug-in author to indicate to the external environment that the output has changed and must be re-uploaded to the GPU.</p>
<h2 id="gpu-processing"><a class="header" href="#gpu-processing">GPU processing</a></h2>
<p>... is not currently supported properly, but is under active investigation.</p>
<p>The two possibilities going forward are: </p>
<ul>
<li>Wrap / conceptify an API not dissimilar to abstraction APIs such as <a href="https://github.com/bkaradzic/bgfx">BGFX</a> or <a href="https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d">Qt RHI</a> which abstract over modern graphics APIs such as Vulkan, Metal and D3D (and retain compatibility with OpenGL).</li>
<li>Make bindings that support compilation to GPU programs, for instance with CUDA or <a href="https://github.com/seanbaxter/shaders/blob/master/README.md">Circle</a>. This is what I think is the best way going forward :-)</li>
</ul>
<h2 id="helpers-2"><a class="header" href="#helpers-2">Helpers</a></h2>
<p>A few types are provided:</p>
<ul>
<li><code>halp::rgba_texture</code></li>
<li><code>halp::texture_input&lt;&quot;Name&quot;&gt;</code> provides methods to get an RGBA pixel: </li>
</ul>
<pre><code class="language-cpp">auto [r,g,b,a] = tex.get(10, 20);
</code></pre>
<ul>
<li><code>halp::texture_output&lt;&quot;Name&quot;&gt;</code> provides methods to set a RGBA pixel: </li>
</ul>
<pre><code class="language-cpp">tex.set(10, 20, {.r = 10, .g = 100, .b = 34, .a = 255});
tex.set(10, 20, 10, 100, 34, 255);
</code></pre>
<p>as well as useful method to initialize and mark the texture ready for upload: </p>
<pre><code class="language-cpp">// Call this in the constructor or before processing starts
tex.create(100, 100);

// Call this after making changes to the texture
tex.upload();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-processor-example"><a class="header" href="#image-processor-example">Image processor example</a></h1>
<p>This example is a very simple image filter. It takes an input image and downscales &amp; degrades it.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;halp/texture.hpp&gt;
#include &lt;cmath&gt;

namespace examples
{
struct TextureFilterExample
{
  halp_meta(name, &quot;My example texture filter&quot;);
  halp_meta(c_name, &quot;texture_filt&quot;);
  halp_meta(category, &quot;Demo&quot;);
  halp_meta(author, &quot;Jean-Michaël Celerier&quot;);
  halp_meta(description, &quot;Example texture filter&quot;);
  halp_meta(uuid, &quot;3183d03e-9228-4d50-98e0-e7601dd16a2e&quot;);

  struct
  {
    halp::texture_input&lt;&quot;In&quot;&gt; image;
  } inputs;

  struct
  {
    halp::texture_output&lt;&quot;Out&quot;&gt; image;
  } outputs;

  // Some initialization can be done in the constructor.
  TextureFilterExample() noexcept
  {
    // Allocate some initial data
    outputs.image.create(1, 1);
  }

  void operator()()
  {
    auto&amp; in_tex = inputs.image.texture;
    auto&amp; out_tex = outputs.image.texture;

    // Since GPU readbacks are asynchronous: reading textures may take some time and
    // thus the data may not be available from the beginning.
    if (in_tex.bytes == nullptr)
      return;

    // Texture hasn't changed since last time, no need to recompute anything
    if (!in_tex.changed)
      return;
    in_tex.changed = false;

    // We (dirtily) downscale by a factor of 16
    if (out_tex.width != in_tex.width || out_tex.height != in_tex.height)
      outputs.image.create(in_tex.width / 16, in_tex.height / 16);

    for (int y = 0; y &lt; in_tex.height / 16; y++)
    {
      for (int x = 0; x &lt; in_tex.width / 16; x++)
      {
        // Get a pixel
        auto [r, g, b, a] = inputs.image.get(x * 16, y * 16);

        // (Dirtily) Take the luminance and compute its contrast
        double contrasted = std::pow((r + g + b) / (3. * 255.), 4.);

        // (Dirtily) Posterize
        uint8_t col = uint8_t(contrasted * 8) * (255 / 8.);

        // Update the output texture
        outputs.image.set(x, y, col, col, col, 255);
      }
    }

    // Call this when the texture changed
    outputs.image.upload();
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-user-interfaces"><a class="header" href="#creating-user-interfaces">Creating user interfaces</a></h1>
<p>We have seen so far that we can specify widgets for our controls. Multiple back-ends may render these widgets in various ways.
This is already a good start for making user interfaces, but most media systems generally have more specific user interface needs.</p>
<p>Avendish allows three levels of UI definition: </p>
<ol>
<li>Automatic: nothing to do, all the widgets corresponding to inputs and outputs of the processor will be generated automatically in a list. This is not pretty but sufficient for many simple cases. For instance, here is how some Avendish plug-ins render in <em>ossia score</em>.</li>
</ol>
<p><img src="advanced/images/ui-basic.png" alt="Basic UI" /></p>
<ol start="2">
<li>Giving layout hints. A declarative syntax allows to layout said items and text in usual containers, auomatically and with arbitrary nesting: hbox, vbox, tabs, split view... Here is, again, an example in <em>ossia score</em>.</li>
</ol>
<p><img src="advanced/images/ui-layout.png" alt="Basic UI" /></p>
<ol start="3">
<li>Creating entirely custom items with a Canvas-based API. It is also possible to load images, make custom animations and handle mouse events.</li>
</ol>
<p><img src="advanced/images/ui-image.png" alt="Basic UI" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="custom-items"><a class="header" href="#custom-items">Custom items</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
