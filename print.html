<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Avendish documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="getting_started/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="getting_started/compiling.html"><strong aria-hidden="true">3.</strong> Compiling</a></li><li class="chapter-item expanded "><a href="getting_started/running.html"><strong aria-hidden="true">4.</strong> Running</a></li><li class="chapter-item expanded affix "><li class="part-title">Writing processors</li><li class="chapter-item expanded "><a href="writing_processors/ports.html"><strong aria-hidden="true">5.</strong> Adding ports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/ports.refactoring.html"><strong aria-hidden="true">5.1.</strong> Simplifying ports</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.helpers.html"><strong aria-hidden="true">5.2.</strong> Helpers for ports</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.html"><strong aria-hidden="true">5.3.</strong> Port metadatas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.range.html"><strong aria-hidden="true">5.3.1.</strong> Range</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.widget.html"><strong aria-hidden="true">5.3.2.</strong> Widget</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.helpers.html"><strong aria-hidden="true">5.3.3.</strong> Helpers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/audio.html"><strong aria-hidden="true">6.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/audio.polyphonic.html"><strong aria-hidden="true">6.1.</strong> Monophonic processors</a></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/messages.html"><strong aria-hidden="true">7.</strong> Messages</a></li><li class="chapter-item expanded "><a href="writing_processors/callbacks.html"><strong aria-hidden="true">8.</strong> Callbacks</a></li><li class="chapter-item expanded "><a href="writing_processors/midi.html"><strong aria-hidden="true">9.</strong> MIDI</a></li><li class="chapter-item expanded "><a href="writing_processors/midi.html"><strong aria-hidden="true">10.</strong> Image</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced features</li><li class="chapter-item expanded "><a href="advanced/ui.html"><strong aria-hidden="true">11.</strong> Custom UI</a></li><li class="chapter-item expanded "><a href="advanced/logging.html"><strong aria-hidden="true">12.</strong> Logging</a></li><li class="chapter-item expanded "><a href="advanced/fft.html"><strong aria-hidden="true">13.</strong> FFT</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="writing_processors/processing.html"><strong aria-hidden="true">14.</strong> Processing semantics</a></li><li class="chapter-item expanded "><a href="advanced/bindings.html"><strong aria-hidden="true">15.</strong> Bindings</a></li><li class="chapter-item expanded "><a href="reference/controls.html"><strong aria-hidden="true">16.</strong> Controls</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Avendish documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="making-media-objects-with-avendish"><a class="header" href="#making-media-objects-with-avendish">Making media objects with Avendish</a></h1>
<p>This book is two things: a tutorial for the usage of Avendish, intertwined with 
an explanation of the concepts and implementation.</p>
<p>Avendish aims to enable media objects / processors authors to write the processor in the most natural way possible, and then to map this to host softwares or languages with so-called zero-cost abstraction.</p>
<blockquote>
<p>By zero-cost abstraction, we mean zero run-time cost. However, we'll see that the system actually enables extremely short compile times compared to the norm in C++.</p>
</blockquote>
<p>The library is borne from:</p>
<ul>
<li>
<p>The necessity to reduce duplication among media processors in C++. </p>
</li>
<li>
<p>Allowing to express the quintessence of a given media processor.</p>
<ul>
<li>There should be no compromise at any point: the user of the library must be able 
to declare all the properties of a media processor, whether it processes audio, video, MIDI, messages, etc...</li>
<li>The way this is expressed should be the simplest possible way in C++, in the sense that the code should be as natural as possible: just declaring variables should be sufficient. The lack of proper reflection in C++ still limits this in a way, but we will see that it is already possible to get quite far !</li>
<li>For a given processor, multiple potential expressions are possible. We aim to capture most possible expressions: for instance, it may be more natural for a given audio processor to implement it in a sample-wise way (each audio sample processed one-by-one), and for another to be implemented through buffer-wise processing.</li>
</ul>
</li>
<li>
<p>The observation that the implementation of a media processor has no reason of depending on any kind of binding library: those are two entirely orthogonal concerns. Yet, due to how the language works, for the longest time writing such a processor necessarily embedded it inside some kind of run-time framework: JUCE, DPF, iPlug, etc. These frameworks are all great, but also all make compromises in terms of what is possible to express. Data types will be limited to a known list, UI will have to be written with a specific UI framework, etc. In contrast, Avendish processors are much more open ; processors can be written in their &quot;canonic&quot; form. The various bindings will then try to map as much as is possible to the environments they are bound to.</p>
</li>
</ul>
<p>In addition, such frameworks are generally not suitable for embedded platforms such as micro-controllers, etc. JUCE does not work on ESP32 :-) </p>
<p>In contrast, Avendish processors can be written in a way that does not depend on <em>any</em> existing library, not even the standard C or C++ libraries, which makes them trivially portable to such platforms. The only required thing is a C++ compiler, really !</p>
<h1 id="why-c"><a class="header" href="#why-c">Why C++</a></h1>
<p>To ease porting of most effects, which are also in C++. Step by step, we will be able to lift them towards maybe higher-level descriptions, but first I believe that having something in C++ is important to allow capturing the semantics of the vast majority of media processors in existence.</p>
<p>Also because this is the language I know best =p</p>
<p>Non-C++ alternatives exist: <a href="https://faust.grame.fr/">FAUST</a> and <a href="https://soul.dev/">SOUL</a> are the two most known and are great inspirations for Avendish ; they focus however mainly on audio processing. Avendish can be used to make purely message-based processors for e.g. Max/MSP and PureData, Python objects, etc. or video processing objects (currently implemented only for <a href="https://ossia.io">ossia score</a>, but could easily be ported to e.g. Jitter for Max, GEM for PureData, etc.).</p>
<h1 id="what-is-really-avendish"><a class="header" href="#what-is-really-avendish">What is really Avendish</a></h1>
<ol>
<li>An ontology for media objects.</li>
<li>An automated binding of a part of the C++ object semantics to other languages and run-time environments.</li>
<li>An example implementation of this until C++ gets proper reflection and code generation features.</li>
<li>Very, very, very, very uncompromising on its goals.</li>
<li>Lots of fun C++20 code !</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor:</p>
<pre><code class="language-cpp">import std;

[[name: &quot;Hello World&quot;]]
export struct MyProcessor
{
  void operator()() { 
    std::print(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<p>... at least, in an alternative universe where C++ has gotten custom attributes and reflection on those, 
and where modules and <code>std::print</code> work consistently across all compilers ; in our universe, this is still a few years away. Keep hope, dear reader, keep hope !</p>
<h1 id="getting-started-for-good"><a class="header" href="#getting-started-for-good">Getting started, for good</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor, which works on 2022 compilers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cstdio&gt;

struct MyProcessor
{
  static consteval auto name() { return &quot;Hello World&quot;; }

  void operator()() { 
    printf(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<p>Yes, it's not much. You may even already have some in your codebase without even being aware of it ! </p>
<p>Now, you may be used to the usual APIs for making audio plug-ins and start wondering about all the things you are used too and that are missing here: </p>
<ul>
<li>Inheritance or shelving function pointers in a C struct.</li>
<li>Libraries: defining an Avendish processor does not in itself require including anything. 
A central point of the system is that everything can be defined through bare C++ constructs, without requiring the user to import types from a library. A library of helpers is nonetheless provided, to simplify some repetitive cases, but is in no way mandatory ; if anything, I encourage anyone to try to make different helper APIs that fit different coding styles.</li>
<li>Functions to process audio such as</li>
</ul>
<pre><code class="language-cpp">void process(double** inputs, double** outpus, int frames);
</code></pre>
<p>We'll see how all the usual amenities can be built on top of this and simple C++ constructs such as variables, methods and structures.</p>
<h2 id="line-by-line"><a class="header" href="#line-by-line">Line by line</a></h2>
<pre><code class="language-cpp">// This line is used to instruct the compiler to not include a header file multiple times.
#pragma once

// This line is used to allow our program to use `printf`:
#include &lt;cstdio&gt;

// This line declares a struct named HelloWorld. A struct can contain functions, variables, etc.
// It could also be a class - in C++, there is no strong semantic difference between either.
struct MyProcessor
{
  // This line declares a function that will return a visible name to show to our 
  // users.
  // - static is used so that an instance of HelloWorld is not needed: 
  //   we can just refer to the function as HelloWorld::name();
  // - consteval is used to enforce that the function can be called at compile-time, 
  //   which may enable optimizations in the backends that will generate plug-ins.
  // - auto because it does not matter much here, we know that this is a string :-)
  static consteval auto name() { return &quot;Hello World&quot;; }

  // This line declares a special function that will allow our processor to be executed as follows: 
  // 
  // HelloWorld the_processor;
  // the_processor();
  //
  // ^ the second line will call the &quot;operator()&quot; function.
  void operator()() 
  { 
    // This one should hopefully be obvious :-)
    printf(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-our-processor"><a class="header" href="#compiling-our-processor">Compiling our processor</a></h1>
<h2 id="environment-set-up"><a class="header" href="#environment-set-up">Environment set-up</a></h2>
<p>Before anything, we need a C++ compiler. The recommandation is to use Clang (at least clang-13). GCC 11 also works with some limitations. Visual Studio is sadly still not competent enough.</p>
<ul>
<li>On Windows, through <a href="https://github.com/mstorsjo/llvm-mingw/releases/tag/20220323">llvm-mingw</a>. </li>
<li>On Mac, through Xcode.</li>
<li>On Linux, through your distribution packages.</li>
</ul>
<p>Avendish's code is header-only ; however, CMake automatizes correctly linking to the relevant libraries, and generates a correct entrypoint for the targeted bindings, thus we recommend installing it.</p>
<p>Ninja is recommended: it makes the build faster.</p>
<p>The APIs and SDK that you wish to create plug-ins / bindings for must also be available: </p>
<ul>
<li>PureData: needs the PureData API.
<ul>
<li>m_pd.h and pd.lib must be findable through <code>CMAKE_PREFIX_PATH</code>.</li>
<li>On Linux this is automatic if you install PureData through your distribution.</li>
</ul>
</li>
<li>Max/MSP: needs the Max SDK.
<ul>
<li>Pass <code>-DAVND_MAXSDK_PATH=/path/to/max/sdk</code> to CMake.</li>
</ul>
</li>
<li>Python: needs pybind11.
<ul>
<li>Installable through most distro's repos.</li>
</ul>
</li>
<li>ossia: needs <a href="https://github.com/ossia/libossia">libossia</a>.</li>
<li>clap: needs <a href="https://github.com/free-audio/clap">clap</a>.</li>
<li>UIs can be built with Qt or <a href="https://github.com/Immediate-Mode-UI/Nuklear">Nuklear</a>.
<ul>
<li>Qt is installable easily through <a href="https://github.com/miurahr/aqtinstall">aqtinstall</a>.</li>
</ul>
</li>
<li>VST3: needs the Steinberg VST3 SDK.
<ul>
<li>Pass <code>-DVST3_SDK_ROOT=/path/to/vst3/sdk</code> to CMake.</li>
</ul>
</li>
<li>By default, plug-ins compatible with most DAWs through an obsolete, Vintage, almost vestigial, API will be built. This does not require any specific dependency to be installed, on the other hand it only supports audio plug-ins.</li>
</ul>
<h2 id="building-the-template"><a class="header" href="#building-the-template">Building the template</a></h2>
<p>The simplest way to get started is from the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/CMakeLists.txt">template repository</a>: simply clear the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.cpp">Processor.cpp</a> file for now and put the content in <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.hpp">Processor.hpp</a>.</p>
<p>Here's a complete example (from bash):</p>
<pre><code class="language-bash">$ git clone https://github.com/celtera/avendish-audio-processor-template
$ mkdir build
$ cd build
$ cmake ../avendish-audio-processor-template
$ ninja # or make -j8
</code></pre>
<p>This should produce various binaries in the build folder: for instance, a PureData object (in <code>build/pd</code>), a Python one (in <code>build/python</code>, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-template-in-python"><a class="header" href="#running-the-template-in-python">Running the template in Python</a></h1>
<p>Once the processor is built, we can for instance run it in Python: </p>
<p>Let's try to run our processor through the Python bindings:</p>
<pre><code class="language-bash">$ cd build/python

# Check that our processor was built correctly
$ ls
pymy_processor.so

# Run it
$ python
&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Hello_World()
&gt;&gt;&gt; proc.process()
Henlo
</code></pre>
<h1 id="running-the-template-in-puredata"><a class="header" href="#running-the-template-in-puredata">Running the template in PureData</a></h1>
<p>Similarly, one can run the template in PureData: </p>
<pre><code class="language-bash">$ cd build/pd

# Check that our processor was built correctly
$ ls
my_processor.l_ia64

# Run it
$ pd -lib my_processor
</code></pre>
<p>Make the following patch:</p>
<p><img src="getting_started/../images/getting_started/pd-hello-world.png" alt="Hello PureData" /></p>
<p>When sending a bang, the terminal in which PureData was launched should also print &quot;Henlo&quot;.
We'll see in a later chapter how to print on Pd's own console instead.</p>
<h1 id="running-in-daws"><a class="header" href="#running-in-daws">Running in DAWs</a></h1>
<p>We could, but so far our object is not really an object that makes sense in a DAW: it does not process audio in any way. We'll see in further chapters how to make audio objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-ports"><a class="header" href="#adding-ports">Adding ports</a></h1>
<p>Our processor so far does not process much. It just reacts to an external trigger, to invoke a print function.</p>
<blockquote>
<p>Note that the way this trigger is invoked varies between environments: in Python, we called a <code>process()</code> function, while in PureData, we sent a bang to our object. That is one of the core philosophies of Avendish: bindings should make it so that the object fits as much as possible with the environment's semantics and idioms.</p>
</blockquote>
<p>Most actual media processing systems work with the concept of ports to declare inputs and outputs, and Avendish embraces this fully.</p>
<p>Here is the code of a simple processor, which computes the sum of two numbers.</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { float value; } a;
    struct { float value; } b;
  } inputs;

  struct
  {
    struct { float value; } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Compiling and running this yields for instance a PureData object which can be used like this:</p>
<p><img src="writing_processors/images/addition.png" alt="Addition" /></p>
<p>Note that the object respects the usual semantics of PureData: sending a message to the leftmost inlet will trigger the computation. Sending a message to the other inlets will store the value internally but won't trigger the actual computation.</p>
<p>For some objects, other semantics may make sense: creating an alternative binding to PureData which would implement another behaviour, such as triggering the computation only on &quot;bang&quot; messages, or on any input on any inlet, would be a relatively easy task.</p>
<p>Let's try in Python:</p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.input_0 = 123
&gt;&gt;&gt; p.input_1 = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.output_0
579.0
</code></pre>
<p>Here the semantics follow usual &quot;object&quot; ones. You set some state on the object and call methods on it, which may change this state. </p>
<blockquote>
<p>One could also make a binding that implements functional semantics, by passing the state of the processor as an immutable object instead. Python is already slow enough, though :p</p>
</blockquote>
<h2 id="syntax-explanation"><a class="header" href="#syntax-explanation">Syntax explanation</a></h2>
<p>Some readers may be surprised by the following syntax: </p>
<pre><code class="language-cpp">struct { float value; } a;
</code></pre>
<p>What it does is declare a variable <code>a</code> whose type is an <em>unnamed</em> structure. 
Note that this is a distinct concept from <em>anonymous</em> structures: </p>
<pre><code class="language-cpp">struct { float value; };
</code></pre>
<p>which are legal in C but not in C++ (although most relevant compilers accept them), and are mostly useful for implementing unions: </p>
<pre><code class="language-cpp">union vec3 {
  struct { float x, y, z; };
  struct { float r, g, b; };
};

union vec3 v; 
v.x = 1.0; 
v.g = 2.0;
</code></pre>
<p>Motivation for using unnamed structures in Avendish is explained afterwards.</p>
<h2 id="naming-things"><a class="header" href="#naming-things">Naming things</a></h2>
<p>In an ideal world, what we would have loved is writing the following code: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    float a;
    float b;
  } inputs;

  struct
  {
    float out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>and have our Python processor expose us variables named <code>a</code>, <code>b</code> and <code>out</code>. Sadly, without reflection on names, this is not possible yet. Thus, in the meantime we use structs to embed metadata relative to the ports: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { 
      static consteval auto name() { return &quot;a&quot;; } 
      float value; 
    } a;
    struct { 
      static consteval auto name() { return &quot;b&quot;; } 
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return &quot;out&quot;; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Now our Python example is cleaner to use: </p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.a = 123
&gt;&gt;&gt; p.b = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.out
579.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h1>
<p>One can see how writing:</p>
<pre><code class="language-cpp">struct { 
  static consteval auto name() { return &quot;foobar&quot;; } 
  float value; 
} foobar;
</code></pre>
<p>for 200 controls would get boring quick. In addition, the implementation of our processing function is not as clean as we'd want: in an ideal world, it would be just: </p>
<pre><code class="language-cpp">void operator()() { outputs.out = inputs.a + inputs.b; }
</code></pre>
<p>Thankfully, we can introduce our own custom abstractions without breaking anything: the only thing that matters is that they follow the &quot;shape&quot; of what a parameter is.</p>
<p>This shape is defined (as a first approximation) as follows:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept parameter = requires (T t) { t.value = {}; };
</code></pre>
<p>In C++ parlance, this means that a type can be recognized as a parameter if</p>
<ul>
<li>It has a member called <code>value</code>.</li>
<li>This member is assignable with some default value.</li>
</ul>
<p>For instance: </p>
<pre><code class="language-cpp">struct bad_1 {
  const int value;
}; 

struct bad_2 {
  void value();
}; 

class bad_3 {
  int value;
}; 
</code></pre>
<p>are all invalid parameters.</p>
<p>This can be ensured easily by <a href="https://gcc.godbolt.org/z/c9Ko4ssM8">asking the compiler</a>: </p>
<pre><code class="language-cpp">static_assert(!parameter&lt;bad_1&gt;);
static_assert(!parameter&lt;bad_2&gt;);
static_assert(!parameter&lt;bad_3&gt;);
</code></pre>
<blockquote>
<p><code>static_assert</code> is a C++ feature which allows to check a predicate at compile-time. If the predicate is false, the compiler will report an error.</p>
</blockquote>
<p>Avendish will simply not recognize them and they won't be accessible anywhere.</p>
<p>Here are examples of valid parameters:</p>
<pre><code class="language-cpp">struct good_1 {
  int value;
}; 

struct good_2 {
  std::string value;
}; 

template&lt;typename T&gt;
struct assignable {
  T&amp; operator=(T x) { 
    printf(&quot;I changed !&quot;);
    this-&gt;v = x;
    return this-&gt;v;
  }
  T v;
};

class good_3 {
  public:
    assignable&lt;double&gt; value;
}; 
</code></pre>
<p>This can be ensured again by <a href="https://gcc.godbolt.org/z/P7aET4q3z">asking the compiler</a>: </p>
<pre><code class="language-cpp">static_assert(parameter&lt;good_1&gt;);
static_assert(parameter&lt;good_2&gt;);
static_assert(parameter&lt;good_3&gt;);
</code></pre>
<p>Avendish provides an helper library, <code>halp</code> (Helper Abstractions for Literate Programming), which match this pattern. However, users are encouraged to develop their own abstractions that fit their preferred coding style :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ports-with-the-helper-library"><a class="header" href="#ports-with-the-helper-library">Ports with the helper library</a></h1>
<p>Here is how our processor looks with the current set of helpers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  // halp_meta(A, B) expands to static consteval auto A() { return B; }
  halp_meta(name, &quot;Addition&quot;)

  struct
  {
    // val_port is a simple type which contains 
    // - a member value of type float
    // - the name() metadata method
    // - helper operators to allow easy assignment and use of the value.
    halp::val_port&lt;&quot;a&quot;, float&gt; a;
    halp::val_port&lt;&quot;b&quot;, float&gt; b;
  } inputs;

  struct
  {
    halp::val_port&lt;&quot;out&quot;, float&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>If one really does not like templates, the following macro could be defined instead to make custom ports: </p>
<pre><code class="language-cpp">#define my_value_port(Name, Type)                  \
  struct {                                         \
    static consteval auto name() { return #Name; } \
    Type value;                                    \
  } Name;

// Used like:
my_value_port(a, float)
my_value_port(b, std::string)
... etc ...
</code></pre>
<p>Likewise if one day the <a href="https://github.com/cplusplus/papers/issues/403">metaclasses</a> proposal comes to pass, it will be possible to convert:</p>
<pre><code class="language-cpp">meta_struct
{
  float a;
  float b;
} inputs;
</code></pre>
<p>into a struct of the right shape, automatically, at compile-time, and all the current bindings will keep working.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="port-metadatas"><a class="header" href="#port-metadatas">Port metadatas</a></h1>
<p>Our ports so far are very simple: floating-point values, without any more information attached than a name to show to the user.</p>
<p>Most of the time, we'll want to attach some semantic metadata to the ports: for instance, a range of acceptable values, the kind of UI widget that should be shown to the user, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-minmax-range"><a class="header" href="#defining-a-minmax-range">Defining a min/max range</a></h1>
<p>Here is how one can define a port with such a range:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;foobar&quot;; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Here is another version which will be picked up too: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;foobar&quot;; } 
  static consteval auto range() {
    struct { 
      float min = -1.;
      float max = 1.;
      float init = 0.5;
    } r;
    return r;
  };

  float value{};
} foobar;
</code></pre>
<p>More generally, in most cases, Avendish will try to make sense of the things the author declares, whether they are types, variables or functions. This is not implemented entirely consistently yet, but it is a goal of the library in order to enable various coding styles and as much freedom of expression as possible for the media processor developer.</p>
<h2 id="keeping-metadata-static"><a class="header" href="#keeping-metadata-static">Keeping metadata static</a></h2>
<p>Note that we should still be careful in our struct definitions to not declare normal member variables for common metadata, which would take valuable memory and mess with our cache lines. This reduces performance for no good reason: imagine instantiating 10000 &quot;processor&quot; objects, you do not want each processor to carry the overhead of storing the range as a member variable, such as this: </p>
<pre><code class="language-cpp">struct {
  const char* name = &quot;foobar&quot;;

  struct {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  } range;

  float value{};
} foobar;

// In this case:
static_assert(sizeof(foobar) == 4 * sizeof(float) + sizeof(const char*));
// sizeof(foobar) == 24 on 64-bit systems

// While in the previous cases, the &quot;name&quot; and &quot;range&quot; information is stored in a static space in the binary ; its cost is paid only once:
static_assert(sizeof(foobar) == sizeof(float));
// sizeof(foobar) == 4
</code></pre>
<h2 id="testing-on-a-processor"><a class="header" href="#testing-on-a-processor">Testing on a processor</a></h2>
<p>If we modify our example processor this way: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { 
      static consteval auto name() { return &quot;a&quot;; } 
      struct range {
        float min = -10.;
        float max = 10.;
        float init = 0.;
      };
      float value; 
    } a;
    struct { 
      static consteval auto name() { return &quot;b&quot;; } 
      struct range {
        float min = -1.;
        float max = 1.;
        float init = 0.;
      };
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return &quot;out&quot;; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>then some backends will start to be able to do interesting things, like showing relevant UI widgets, or clamping the inputs / outputs.</p>
<p>This is not possible in all back-ends, sadly. Consider for instance PureData: the way one adds a port is by passing a pointer to a floating-point value to Pd, which will write directly the inbound value at the memory address: there is no point at which we could plug-in to perform clamping of the value. </p>
<p>Two alternatives would be possible in this case: </p>
<ul>
<li>Change the back-end to instead expect all messages on the first inlet, as those can be captured. This would certainly yield lower performance as one now would have to pass a symbol indicating the parameter so that the object knows to which port the input should map.</li>
<li>Implement an abstraction layer which would duplicate the parameters with their clamped version, and perform the clamping on all parameters whenever the process function gets called. This would however be hurtful in terms of performance and memory use.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-ui-widgets"><a class="header" href="#defining-ui-widgets">Defining UI widgets</a></h1>
<p>Avendish can recognize a few names that will indicate that a widget of a certain type must be created.</p>
<p>For instance: </p>
<pre><code class="language-cpp">struct {
  enum { knob };
  static consteval auto name() { return &quot;foobar&quot;; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Simply adding the enum definition in the struct will allow the bindings to detect it at compile-time, and instantiate an appropriate UI control.</p>
<p>The following widget names are currently recognized: </p>
<pre><code>bang, impulse
button, pushbutton
toggle, checkbox,
hslider, vslider, slider
spinbox,
knob,
lineedit,
choices, enumeration
combobox, list
xy,
color,
hbargraph, vbargraph, bargraph
</code></pre>
<p>This kind of widget definition is here to enable host DAWs to automatically generate appropriate UIs automatically.</p>
<p>A further chapter will present how to create entirely custom painted UIs and widgets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-helpers"><a class="header" href="#widget-helpers">Widget helpers</a></h1>
<p>To simplify the common use case of defining a port such as &quot;slider with a range&quot;, a set of common helper types is provided.</p>
<p>Here is our example, now as refined as it can be ; almost no character is superfluous or needlessly repeated except the names of controls:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  halp_meta(name, &quot;Addition&quot;)

  struct
  {
    halp::hslider_f32&lt;&quot;a&quot;, halp::range{.min = -10, .max = 10, .init = 0}&gt; a;
    halp::knob_f32&lt;&quot;b&quot; , halp::range{.min = -1, .max = 1, .init = 0}&gt; b;
  } inputs;

  struct
  {
    halp::hbargraph_f32&lt;&quot;out&quot;, halp::range{.min = -11, .max = 11, .init = 0}&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>This is how an environment such as <em>ossia score</em> renders it: </p>
<p><img src="writing_processors/images/addition-score.gif" alt="Addition" /></p>
<p>Note that even with our helper types, the following holds:</p>
<pre><code>static_assert(sizeof(MyProcessor) == 3 * sizeof(float));
</code></pre>
<p>That is, an instance of our object weighs in memory exactly the size of its inputs and outputs, nothing else. In addition, the binding libraries try extremely hard to not allocate any memory dynamically, which leads to very concise memory representations of our media objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-audio-processors"><a class="header" href="#writing-audio-processors">Writing audio processors</a></h1>
<p>The processors we wrote until now only processed &quot;control&quot; values.</p>
<p>As a convention, those are values that change infrequently, relative to the audio rate: every few milliseconds, as opposed to every few dozen microseconds for individual audio samples.</p>
<h2 id="argument-based-processors"><a class="header" href="#argument-based-processors">Argument-based processors</a></h2>
<p>Let's see how one can write a simple audio filter in Avendish: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }

  float operator()(float input) 
  {
    return std::tanh(input); 
  }
};
</code></pre>
<p>That's it. That's the processor :-)</p>
<p>Maybe you are used to writing processors that operate with buffers of samples. Fear not, here is another valid Avendish audio processor, which should reassure most readers:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  static consteval auto input_channels() { return 2; }
  static consteval auto output_channels() { return 2; }

  void operator()(double** inputs, double** outputs, int frames)
  {
    for (int c = 0; c &lt; input_channels(); ++c)
    {
      for (int k = 0; k &lt; frames; k++)
      {
        outputs[c][k] = std::tanh(inputs[c][k]);
      }
    }
  }
};
</code></pre>
<p>The middle-ground of a processor that processes a single channel is also possible (and so is the possibility to use floats or doubles for the definition of the processor):</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }

  void operator()(float* inputs, float* outputs, int frames)
  {
    for (int k = 0; k &lt; frames; k++)
    {
      outputs[k] = std::tanh(inputs[k]);
    }
  }
};
</code></pre>
<p>Those are all ways that enable quickly writing very simple effects (although a lot of ground is already covered).
For more advanced systems, with side-chains and such, it is preferable to use proper ports instead.</p>
<h2 id="port-based-processors"><a class="header" href="#port-based-processors">Port-based processors</a></h2>
<p>Here are three examples of valid audio ports:</p>
<ul>
<li>Sample-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;In&quot;; }
  float sample{};
};
</code></pre>
<ul>
<li>Channel-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Out&quot;; }
  float* channel{};
};
</code></pre>
<ul>
<li>Bus-wise, with a fixed channel count. Here, bindings will ensure that there are always as many channels allocated.</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Ins&quot;; }
  static constexpr int channels() { return 2; }
  float** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<ul>
<li>Bus-wise, with a modifiable channel count. Here, bindings will put exactly as many channels as the end-user of the software requested ; this count will be contained in <code>channels</code>. </li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Outs&quot;; }
  int channels = 0;
  double** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<p><code>halp</code> provides helper types for these common cases: </p>
<pre><code class="language-cpp">halp::audio_sample&lt;&quot;A&quot;, double&gt; audio;
halp::audio_channel&lt;&quot;B&quot;, double&gt; audio;
halp::fixed_audio_bus&lt;&quot;C&quot;, double, 2&gt; audio;
halp::dynamic_audio_bus&lt;&quot;D&quot;, double&gt; audio;
</code></pre>
<blockquote>
<p>Important: it is not possible to mix different types of audio ports in a single processor: audio sample and audio bus operate necessarily on different time-scales that are impossible to combine in a single function. Technically, it would be possible to combine audio channels and audio buses, but for the sake of simplicity this is currently forbidden.</p>
</blockquote>
<blockquote>
<p>Likewise, it is forbidden to mix float and double inputs for audio ports (as it simply does not make sense: no host in existence is able to provide audio in two different formats at the same time).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monophonic-processors"><a class="header" href="#monophonic-processors">Monophonic processors</a></h1>
<p>There are three special cases: </p>
<ol>
<li>Processors with one sample input and one sample output.</li>
<li>Processors with one channel input and one channel output.</li>
<li>Processors with one dynamic bus input, one dynamic bus output, and no fixed channels being specified.</li>
</ol>
<p>In these three cases, the processor is recognized as polyphony-friendly. That means that in cases 1 and 2, the processor will be instantiated potentially multiple times automatically, if used in e.g. a stereo DAW.</p>
<p>In case 3, the channels of inputs and outputs will be set to the same count, which comes from the host.</p>
<h2 id="polyphonic-processors-should-use-types-for-their-io"><a class="header" href="#polyphonic-processors-should-use-types-for-their-io">Polyphonic processors should use types for their I/O</a></h2>
<p>Let's consider the following processor:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct {
    struct { float value; } gain;
  } inputs;

  double operator()(double input) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(inputs.gain.value * input + accumulator); 
  }
  
private:
  double accumulator{};
};
</code></pre>
<p>We have three different values involved: </p>
<ul>
<li><code>input</code> is the audio sample that is to be processed.</li>
<li><code>inputs.gain.value</code> is an external control which increases or decreases the distortion.</li>
<li><code>accumulator</code> is an internal variable used by the processing algorithm.</li>
</ul>
<p>Now consider this in the context of polyphony: the only thing that we can do is instantiate <code>MyProcessor</code> three times.</p>
<ul>
<li>We cannot call <code>operator()</code> of a single instance on multiple channels, as the internal state must stay independent of the channels.</li>
<li>But now the inputs are duplicated for all instances. If we want to implement a filter bank with thousands of duplicated processors in parallel, this would be a huge waste of memory if they all depend on the same <code>gain</code> value.</li>
</ul>
<p>Thus, it is recommended in this case to use the following form: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct inputs {
      struct { float value; } gain;
  };
  struct outputs { };

  double operator()(double input, const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(ins.gain.value * input + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Here, Avendish will instantiate a single <code>inputs</code> array, which will be shared across all polyphony voices, which will likely use less memory and be more performant in case of large amount of parameters &amp; voices.</p>
<p>Here is what I would term the &quot;canonic&quot; of this version, with additionally our helpers to reduce typing, and the audio samples passed through ports instead of through arguments:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct inputs {
    halp::audio_sample&lt;&quot;In&quot;, double&gt; audio;
    halp::hslider_f32&lt;&quot;Gain&quot;, halp::range{.min = 0, .max = 100, .init = 1}&gt; gain;
  };
  struct outputs { 
    halp::audio_sample&lt;&quot;A&quot;, double&gt; audio;
  };

  void operator()(const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator + 0.01f, 10.f);
    outs.audio = std::tanh(ins.gain * ins.audio + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Passing inputs and outputs as types is also possible for all the other forms described previously - everything is possible, write your plug-ins as it suits you best :) and who knows, maybe with metaclasse one would also be able to generate the more efficient form directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>So far, we already have something which allows to express a great deal of audio plug-ins, as well as many objects that do not operate in a manner synchronized to a constant sound input, but also in a more asynchronous way, and with things more complicated than single <code>float</code>, <code>int</code> or <code>string</code> values.</p>
<p>A snippet of code is worth ten thousand words: here is how one defines a message input.</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct messages {
    struct {
      static consteval auto name() { return &quot;dump&quot;; }
      void operator()(MyProcessor&amp; p, double arg1, const std::string&amp; arg2) {
        std::cout &lt;&lt; arg1 &lt;&lt; &quot;;&quot; &lt;&lt; arg2 &lt;&lt; &quot;\n&quot;;
      }
    } my_message;
  };
};
</code></pre>
<p>Messages are of course only meaningful in environments which support them. 
One argument messages are equivalent to arguments.
If there is more than one arguments, not all host systems may be able to handle them ; for instance, it does not make much sense for VST plug-ins. On the other hand, programming language bindings or systems such as Max and PureData have no problem with them.</p>
<h2 id="passing-existing-functions"><a class="header" href="#passing-existing-functions">Passing existing functions</a></h2>
<p>The following syntaxes are also possible:</p>
<pre><code class="language-cpp">void free_function() { printf(&quot;Free function\n&quot;); }

struct MyProcessor {
  void my_member(int x);

  struct messages {
    // Using a pointer-to-member function
    struct {
      static consteval auto name() { return &quot;member&quot;; }
      static consteval auto func() { return &amp;MyProcessor::my_member; }
    } member;

    // Using a lambda-function
    struct
    {
      static consteval auto name() { return &quot;lambda_function&quot;; }
      static consteval auto func() {
        return [] { printf(&quot;lambda\n&quot;); };
      }
    } lambda;

    // Using a free function
    struct
    {
      static consteval auto name() { return &quot;function&quot;; }
      static consteval auto func() { return free_function; }
    } freefunc;
  };
};
</code></pre>
<p>In every case, if one wants access to the processor object, it has to be the first argument of the function (except the non-static-member-function case where it is not necessary as the function already has access to the <code>this</code> pointer by definition).</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type-checking</a></h2>
<p>Messages are type-checked: in the example above, for instance, PureData will return an error for the message <code>[dump foo bar&gt;</code>. For the message <code>[dump 0.1 bar&gt;</code> things will however work out just fine :-)</p>
<h2 id="arbitrary-inputs"><a class="header" href="#arbitrary-inputs">Arbitrary inputs</a></h2>
<p>It may be necessary to have messages that accept an arbitrary number of inputs.
Here is how: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;args&quot;; }
  void operator()(MyProcessor&amp; p, std::ranges::input_range auto range) {
    for(const std::variant&amp; argument : range) {
      // Print the argument whatever the content
      // (a library such as fmt can do that directly)
      std::visit([](auto&amp; e) { std::cout &lt;&lt; e &lt;&lt; &quot;\n&quot;; }, argument);

      // Try to do something useful with it - here the types depend on what the binding give us. So far only Max and Pd support that so the only possible types are floats, doubles and std::string_view
      if(std::get_if&lt;double&gt;(argument)) { ... }
      else if(std::get_if&lt;std::string_view&gt;(argument)) { ... }
      // ... etc
    }
  }
} my_variadic_message;
</code></pre>
<h1 id="overloading"><a class="header" href="#overloading">Overloading</a></h1>
<p>Overloading is not supported yet, but there are plans for it.</p>
<h1 id="how-does-the-above-code-work-"><a class="header" href="#how-does-the-above-code-work-">How does the above code work ?</a></h1>
<p>I think that this case is pretty nice and a good example of how C++ can greatly improve type safety over C APIs: a common problem for instance with Max or Pd is accessing the incorrect member of an union when iterating the arguments to a message.</p>
<p>Avendish has the following method, which transforms a Max or Pd argument list, into an iterable coroutine-based range of <code>std::variant</code>.</p>
<pre><code class="language-cpp">using atom_iterator = avnd::generator&lt;std::variant&lt;double, std::string_view&gt;&gt;;
inline atom_iterator make_atom_iterator(int argc, t_atom* argv)
{
  for (int i = 0; i &lt; argc; ++i) {
    switch (argv[i].a_type) {
      case A_FLOAT: {
        co_yield argv[i].a_w.w_float;
        break;
      }
      case A_SYM: {
        co_yield std::string_view{argv[i].a_w.w_sym-&gt;s_name};
        break;
      }
      default:
        break;
    }
  }
}
</code></pre>
<p>Here, <code>atom_iterator</code> is what gets passed to <code>my_variadic_message</code>. It allows to deport the iteration of the loop over the arguments into the calling code, but handles the matching from type to union member in a generic way, which removes an entire class of errors.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
